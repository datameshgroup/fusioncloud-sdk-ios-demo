//
//  Crypto.swift
//  TestApplication
//
//  Created by loey on 2/12/22.
//  Copyright Â© 2022 loey. All rights reserved.
//

import Foundation
import CommonCrypto
import IDZSwiftCommonCrypto

class Crypto {
    
    func generate16ByteKey()->[UInt8]{
        var bytes = [Int8](repeating: 0, count: 16) //create 16 byte
        let byteKey = SecRandomCopyBytes(kSecRandomDefault, bytes.count, &bytes) //array copy in java

        if byteKey == errSecSuccess { // Always test the status.
            print("generated byteKey => \(bytes)")
        }

        return [UInt8]()
    }
//
//    func generate16ByteKey()->[UInt8]{
//        let secured = try! Random.generateBytes(byteCount: 16)
//        return secured
//    }
    
    func generateSecurityTrailer()-> (String, String) {
        let KEK = "44DACB2A22A4A752ADC1BBFFE6CEFB589451E0FFD83F8B21"
        let key = generate16ByteKey()
        let encryptedKey = generateEncryptedKey(randomKey: key, KEK: KEK)
        
        print("encryptedKey => \(encryptedKey)  \(encryptedKey.count)")
    
        
        
        let encryptedHexKey = Data(encryptedKey).hexEncodedString().uppercased()
        let macBody = buildMacBody()
        
        print("macBody \(macBody)")
        
        let hexKey = Data(key).hexEncodedString()
        let MAC = generateMAC(request: macBody, randomKeyHex: hexKey).uppercased()
        
        print("MAC => \(MAC)")

        return (encryptedHexKey, MAC)
        
    }
    
    var serviceId: String = ""
    
    
    func randomString(length: Int) -> String {

        let letters : NSString = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        let len = UInt32(letters.length)

        var randomString = ""

        for _ in 0 ..< length {
            let rand = arc4random_uniform(len)
            var nextChar = letters.character(at: Int(rand))
            randomString += NSString(characters: &nextChar, length: 1) as String
        }

        return randomString
    }
    
    func buildMacBody()-> String {
        
        serviceId = randomString(length: 10)
        
        
        return "\"MessageHeader\":{\"MessageCategory\":\"Login\",\"MessageClass\":\"Service\",\"MessageType\":\"Request\",\"POIID\":\"POI ID\",\"ProtocolVersion\":\"3.1-dmg\",\"SaleID\":\"SALE ID\",\"ServiceID\":\"\(serviceId)\"},\"LoginRequest\":{\"DateTime\":\"2022-03-19T15:46:17+08:00\",\"OperatorLanguage\":\"en\",\"SaleSoftware\":{\"ApplicationName\":\"POS Retail\",\"CertificationCode\":\"98cf9dfc-0db7-4a92-8b8cb66d4d2d7169\",\"ProviderIdentification\":\"Company A\",\"SoftwareVersion\":\"01.00.00\"},\"SaleTerminalData\":{\"SaleCapabilities\":[\"CashierStatus\",\"CustomerAssistance\",\"PrinterReceipt\"],\"TerminalEnvironment\":\"SemiAttended\"}}"
    }
    
    func generateEncryptedKey(randomKey: [UInt8], KEK: String )-> [UInt8]{
        return encryptTripleDes(dataString: Data(randomKey).hexEncodedString() , key: KEK)
    }
    
    func crypt(value: [UInt8], randomHex: String )-> [UInt8]{
        return encryptTripleDes2(dataString: Data(value).hexEncodedString() , key: randomHex)
    }
    
    func encryptTripleDes2(dataString: String, key: String)-> [UInt8]{
        
        var keyBytes = stringToBytes(key)
        var value = stringToBytes(dataString)
        
        print("key -> \(key)")
        print("byteArray -> \(keyBytes) , count-> \(keyBytes?.count)")
        
        if(keyBytes?.count == 16){
            var tempKey = [UInt8](repeating: 0, count: 24)
            tempKey[0...15] = (keyBytes?[0...15])!
            
            print("tempkey -> \(tempKey) , count -> \(tempKey.count)")
            
            tempKey[16...23] = (keyBytes?[0...7])!
           
            print("tempkey -> \(tempKey) , count -> \(tempKey.count)")
            
            keyBytes = tempKey
        }
        
        print("keybytes -> \(keyBytes) , count: \(keyBytes?.count)")
        
        var iv = [UInt8]()
        iv.append(UInt8(0))
        iv.append(UInt8(0))
        iv.append(UInt8(0))
        iv.append(UInt8(0))
        iv.append(UInt8(0))
        iv.append(UInt8(0))
        iv.append(UInt8(0))
        iv.append(UInt8(0))
        
        let cryptor = Cryptor(operation: StreamCryptor.Operation.encrypt, algorithm: StreamCryptor.Algorithm.tripleDES, mode: StreamCryptor.Mode.CBC, padding: .NoPadding, key: keyBytes!, iv: iv).update(value!)?.final()

        
        //let cipherText = cryptor.update(value!)?.final()
        print("encrypted => \(String(describing: cryptor))")
        return cryptor!
    }
    
    func encryptTripleDes(dataString: String, key: String)-> [UInt8]{
        
        print("key -> \(key)")
        print("byteArray -> \(stringToBytes(key)) , count->")
        
        
        print("value \(stringToBytes(dataString))")
        let value = stringToBytes(dataString)
        print("valueCount \(value?.count)")
        print("keybytes \(dataString.count)")
        print("keybytes \(key.count)")
        let keyBytes = arrayFrom(string: key.uppercased())
        
        print("keybytes \(keyBytes.count)")
        print("key => \(key)")
        let key = stringToBytes(key)
        
        
        
        var iv = [UInt8]()
        iv.append(UInt8(0))
        iv.append(UInt8(0))
        iv.append(UInt8(0))
        iv.append(UInt8(0))
        iv.append(UInt8(0))
        iv.append(UInt8(0))
        iv.append(UInt8(0))
        iv.append(UInt8(0))
        
        let cryptor = Cryptor(operation: StreamCryptor.Operation.encrypt, algorithm: StreamCryptor.Algorithm.tripleDES, mode: StreamCryptor.Mode.CBC, padding: .NoPadding, key: key!, iv: iv)

        
        let cipherText = cryptor.update(value!)?.final()
        print("encrypted => \(String(describing: cipherText))")
        return cipherText!
    }
    
    func decryptTripleDes(value:String, key: String){
        let key = arrayFrom(hexString: key)
        
        var iv = [UInt8]()
        iv.append(UInt8(0))
        iv.append(UInt8(0))
        iv.append(UInt8(0))
        iv.append(UInt8(0))
        iv.append(UInt8(0))
        iv.append(UInt8(0))
        iv.append(UInt8(0))
        iv.append(UInt8(0))
        
        let cryptor = Cryptor(operation:.decrypt, algorithm:.tripleDES, options:.PKCS7Padding, key:key, iv:iv)
        let decryptedPlainText = cryptor.update(value)?.final()
        let decryptedString = decryptedPlainText!.reduce("") { $0 + String(UnicodeScalar($1)) }
        print("decrypted => \(decryptedString)")
        if(decryptedString == value){
            print("success")
        }
    }
    

    
    func getSHA(input: String)-> [UInt8]? {
        let data = Data(input.utf8)
        var digest = [UInt8](repeating: 0, count: Int(CC_SHA1_DIGEST_LENGTH))
        data.withUnsafeBytes{
            _ = CC_SHA1($0, CC_LONG(data.count), &digest)
        }
        print("Input value => \(input)")
        return stringToBytes(data.hexEncodedString())
    }
    
    func append8Bytes(h :[UInt8])-> [UInt8]{
    
        var hashData = Data(h)
        hashData.append(UInt8(0))
        hashData.append(UInt8(0))
        hashData.append(UInt8(0))
        hashData.append(UInt8(0))
        hashData.append(UInt8(0))
        hashData.append(UInt8(0))
        hashData.append(UInt8(0))
        hashData.append(UInt8(0))
        
        return [UInt8](hashData)
    }
    
    func getLast8Bytes(encrypt: [UInt8])-> [UInt8]{
        //create byte array with size of 8 bytes
        //todo:- get the 8 bytes from 32 bytes and return it back
        
        print("original before get last 8 bytes \(encrypt) size \(encrypt.count)")
        
        let byte8Value = Array(encrypt[25...32])
        return byte8Value
    }
    
    func generateMAC(request: String, randomKeyHex: String)-> String{
        
        //Data(randomKey).hexEncodedString()
        let hashResult = getSha256(s: request)//replace with request
        let hashAppendedBytes = append8Bytes(h: hashResult)
        //let encrypt = encryptTripleDes(dataString: Data(hashAppendedBytes).hexEncodedString(), key: "44DACB2A22A4A752ADC1BBFFE6CEFB589451E0FFD83F8B21") //used" the KEK default
        let encrypt = crypt(value: hashAppendedBytes, randomHex: randomKeyHex)
        let last8bytes = getLast8Bytes(encrypt: encrypt)
        return Data(last8bytes).hexEncodedString()
    }
    
    func getSha256(s: String)->[UInt8]{
        var sha = Digest(algorithm: .sha256).update(s)?.final()
        return sha!
    }
    
    func stringToBytes(_ string: String) -> [UInt8]? {
        let length = string.count
        if length & 1 != 0 {
            return nil
        }
        var bytes = [UInt8]()
        bytes.reserveCapacity(length/2)
        var index = string.startIndex
        for _ in 0..<length/2 {
            let nextIndex = string.index(index, offsetBy: 2)
            if let b = UInt8(string[index..<nextIndex], radix: 16) {
                bytes.append(b)
            } else {
                return nil
            }
            index = nextIndex
        }
        return bytes
    }

    //let bytes = stringToBytes("7661706f72")
    //print(String(bytes: bytes!, encoding: .utf8)) //->Optional("vapor")
}

extension Data {
    struct HexEncodingOptions: OptionSet {
        let rawValue: Int
        static let upperCase = HexEncodingOptions(rawValue: 1 << 0)
    }

    func hexEncodedString(options: HexEncodingOptions = []) -> String {
        let format = options.contains(.upperCase) ? "%02hhX" : "%02hhx"
        return self.map { String(format: format, $0) }.joined()
    }
}

extension NSMutableData {
    func appendByte(b: UInt8) {
        self.appendByte(b: b)
    }
}
